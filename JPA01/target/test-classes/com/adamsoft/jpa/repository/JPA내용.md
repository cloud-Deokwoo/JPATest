## Spring JPA
### ORM(Object Relational Mapping)
  - 객체 지향 패러다음을 관계형 데이터베이스에 보존하는 기술
  - 객체와 관계형 데이터베이스의 테이블을 매핑해서 사용하는 방법
  - 관계형 데이터베이스에서는 Table을 설계하는데 새로운 Table에는 컬럼을 정의하고, 컬럼에 맞는 데이터 타입을 지정해서 데이터를 보관하는 틀을 만든다는 의미에서 Class와 상당히 유사
  - 클래스는 데이터베이스의 데이블과 매핑하기 위해서 만들어진 것이 아니기 때문에 RDB테이블과 어쩔 수 없는 불일치가 존재하는 ORM은 이 둘의 불일치와 제약사항을 해결하는 역할을 담당함. 

![테이블과 클래스](../../../../../ORM1.png)  

  - Class와 Table이 유사하듯 Instance와 Row(Record, Tuple)도 유사하며 객체 지향에서는 Class를 이용하여 객체(Instance)를 생성해서 데이터를 보관하는데 관계형 데이터베이스에서는 Table에 Row를 이용해서 데이터를 저장하며 차이는 객체 라는 단어가 데이터+행위(메서드)라는 의미라면 Row는 데이터만을 의미함
  - 관계(Relation)와 참조(Reference)라는 의미도 유사한데 관계형 데이터베이스는 Table사이의 관계를 통해서 구조적인 데이터를 표현한다면 객체 지향에서는 참조를 통해서 어떤 객체가 다른 객체들과 어떤 관계를 맺고 있는지를 표현
  - 객체 지향과 관계형 데이터베이스는 유사한 특징을 가지고 있어서 객체 지향을 자동으로 관계형 데이터베이스에 맞게 처리해 주는 기법에 대해서 아이디어를 내기 시작했고 그것이 ORM의 시작임.
  - ORM은 완전히 새로운 패러다임을 주장하는 것이 아니라 객체 지향과 관계형 사이의 변환기법을 의미하는 것으로 특정 언어에 국한되는 개념이 아니고, 관계형 패러다음을 가지고 있다면 데이터베이스의 종류를 구분하지 않음
  - 대다수의 객체 지향 언어에서는 ORM을 위한 여러 프레임워크들이 존재함. 
  
  - 장점
    - 특정 데이터베이스에 종족되지 않음
    - 객체 지향적 프로그래밍
    - 생성성 향상
     
  - 단점
    - 복잡한 쿼리 처리
    - 성능 저하 위험
    - 학습 시간

---
#### JPA(Java Persistence API)
  - 자바 ORM기술에 대한 API표준
  - JPA는 인터페이스이고, 이를 구현한 대표적인 구현체로 Hibernate, EclipseLink, DataNucleus, OpenJpa, TopLink등이 있음
  - JPA인터페이스를 구현한 가장 대표적인 오픈 소스가 Hibernate이고, Spring Data JPA는 Hibernate를 쉽게 사용할 수 있는 추가적인 API를 제공하고 있음. 
  
![ORM과 Hibernate구현체 동작](../../../../../JPA1.png)  

#### 영속성 컨텍스트
  - 애플리케이션과 데이터베이스 사이에서 엔티티와 레코드의 괴리를 해소하는 기능과 객체를 보관하는 기능을 수행
  - 엔티티 객체가 영속성 컨덱스트에 들어오면 JPA는 엔티티 객체의 매핑 정보를 데이터베이스에 반영하는 작업을 수행
  - 엔티티 객체가 영속성 컨텍스트에 들어와 JPA의 관리 대상이 되는 시점부터는 해당 객체를 영속 객체(Persistence Object)라고 부름
  - 영속성 컨텍스트는 세션 단위의 생명주기를 가지는데 데이터베이스에 접근하기 위한 세션이 생성되면 영속성 컨텍스트가 만들어지고 세션이 종료되면 영속성 컨테스트도 없어짐
  
![영속성컨텍스트](../../../../../영속성컨텍스트.png)

  - 동작방식
  
![영속성동작방식](../../../../../영속성동작방식.png)

  - 구성 요소
    - Entity
      - 데이터베이스의 Table에 대응하는 Class
      - @Entity가 붙은 Class가 JPA에서 관리하는 Entity
      - 데이터베이스에 item Table을 만들고 이에 대응되는 Itme.java Class를 만들어서 @Entity을 붙이면 이 Class가 Entity가 됨
      - Class 자체나 생성한 Instance도 Entity라고 부름
      
    - Entity Manager Factory
      - Entity Manager Instance를 관리하는 주체
      - 애플리케이션 실행 시 한 개만 만들어지며 사용자로부터 요청이 들어오면 Entity Manager팩토리로부터 Entity Manager를 생성
      
    - Entity Manager
      - 영속성 컨텍스트에 접근하여 Entity에 대한 데이터베이스 작업을 제공
      - 내부적으로 데이베이스 커넥션을 사용하여 데이터베이스에 접근
      - 세부 메서드
        - Find() : 영속성 컨텍스트에서 Entity를 검색하고 영속성 컨텍스트에 없을 경우, 데이터베이스에서 데이터를 찾아 영속성 컨텍스트에 저장
        - persist() : Entity를 영속성 컨텍스트에 저장
        - remove() : Entity Class를 영속성 컨텍스트에서 삭제
        - flush() : 영속성 컨텍스트에 저장된 내용을 데이터베이스에 반영
        
    - Persistence Context
      - Entity를 영구 저장하는 환경으로 Entity Manager를 통해 영속성 컨텍스트에 접근
      
  
  - Entity 수명 주기
  
![Entity수명주기](../../../../../Entity수명주기.png)

    - 비영속(New) : new 키워드를 통해 생성된 상태로 영속성 컨텍스와 관련이 없는 상태
    
    - 영속(managed)
      - Entity가 영속성 컨텍스트에 저장된 상태로 영속성 컨텍스트에 의해 관리되는 상태
      - 영속 상태에서 데이터베이스에 저장되지 않으면 트랜잭선 Commit시점에 데이터베이스에 반영

    - 준영속(detached) : 영속성 컨텍스트에 Entity가 저장되었다가 분리된 상태
    
    - 삭제(removed) : 영속성 컨텍스트와 데이터베이스에서 삭제된 상태 
    
    
- Persistence Context 사용 이유
    - 영속성 컨텍스트는 애플이케이션과 데이터베이스 사이의 중간 계층
    - 중간 계층을 만들면 버퍼링, 캐싱 등을 활용할 수 있는 장점
    
![영속성컨텍스트사용이유](../../../../../영속성컨텍스트사용이유.png)

  - 1차 캐시
      - 영속성 컨텍스트에서는 1차 캐시가 존재하면 Map<key,value>을 이용해서 저장
      - entityManager.find() 호출시 영속성 컨텍스트의 1차 캐시를 조회하여 Entity가 존재할 경우 해당 Entity를 반환하고, Entity가 없으면 데이터베이스에서 조회 후 1차 캐시에 저장 및 반환
  - 동일성 보장
      - 하나의 트랜잭션에서 같은 키 값으로 영속성 컨텍스트에 저장된 Entity조회 시 같은 Entity조회를 보장
      - 1차 캐시에 저장되 Entity를 조회하기 때문에 가능
    
  - 트랜잭션을 지원하는 Class와 Table이 유사하듯 쓰기 지연
      - 영속성 컨텍스트에는 쓰기 지연 SQL저장소가 존재
      - entityManager.persist()를 호출하면 1차 캐시에 저장되는 것과 동시에 쓰기지연 SQL 저장소에 SQL문이 저장되며는데 이렇게 SQL을 쌓아두고 트랜잭션을 Commit하는 시점에 저장된 SQL문들이 flush되면서 데이터베이스에 반영됨
      - 모아서 보내기 때문에 성능에서 이점을 볼 수 있음
      
![영속성컨텍스트사용이유2](../../../../../영속성컨텍스트사용이유2.png) 

  - 변경 감지
    - JPA는 1차 캐시에 데이터베이스에서 처음 불러온 Entity의 스냅샷 값을 갖고 있으며 1차 캐시에 저장된 Entity와 스냅샷을 비교후 변경 내용이 있다면 - - UPATE SQL문을 쓰기 지연 SQL저장소에 담아두고 데이터베이스에 Commit시점에 변경 내용을 자동으로 반영
      - update문을 호출할 필요가 없음   